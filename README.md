# cuda_learning
记录学习Cuda编程的项目

## One Day:

任务清单：配置GPU环境以及创建GPU版的Hello world!

### 一、配置GPU编程环境

主要参考[这篇文章](https://blog.csdn.net/chen565884393/article/details/127905428)

首先检查N卡的驱动，并安装对应的CUDA，然后安装CUDNN

因为我的是GTX1060，所以只能支持CUDA11.4，注意这里我才过坑，安装了11.5,11.6版本在后面对cu程序进行编译的时候会报错，因此要注意显卡能支持的最高CUDA版本，然后根据CUDA版本确定 Visual Studio的版本，

因为官网默认下载最新版本，实际上是不支持古早的CUDA版本的，因此可以根据上面文章提到连接查询官方CUDA支持的VS范围，**注意此处的版本十分重要，如果版本错误会导致后面编译失败**

我最开始下载的是VS 2022 community 的版本，即使在里面选择安装2019,2017的编译器仍然会报错误，提示头文件找不到，或者版本的问题，改回2019版本的就没问题了。

### 二、Hello world

对于GPU编程主要分为两部分，一部分是主机(host)，另一部分则是设备(Device)

主机代码主要在CPU上运行，设备代码则是在GPU上运行完成

我们可以在CPU上运行逻辑分支，然后调用GPU进行计算，但这里GPU的计算与主机是异步的。

调用GPU的函数之后，CPU的控制权依然会往下运行，如果CPU后面的代码可以主动调用同步操作`cudaDeviceSynchronize`函数来同步，这里CPU会阻塞等待GPU完成计算。

同时也可以调用`cudaMemcpy`在主机和设备间拷贝数据时，这里CPU也会阻塞来隐式同步数据。

## Two Day:

GPU编程主要语法与C语言类似，主要是多了一些特殊标识符

$$
\begin{array}{|c|c}
\hline
限定符 & 执行 & 调用 & 备注\\
\_\_{global}\_\_ & 设备端执行 & 主机调用，也可以从算力3以上的设备中调用 & 返回类型必须是void \\
\_\_{device}\_\_ & 设备端执行 & 仅能从设备中调用  \\
\_\_{host}\_\_ & 主机端执行 & 仅能从主机调用 & 可省略 \\ 
\hline
\end{array}
$$

### 代码要点

对于GPU调用时，其线程创建模型为两个部分，第一个部分叫网格(grid),第二个叫线程块(block),线程块包含了N个线程，结构图如下：

```
                                            每一个Grid
----------------------------      -------------------------------
|        |        |        |      |         |         |         |
| grid1  | grid2  | grid3  |      | block1  | block2  | block3  |
|--------------------------|      |-----------------------------|
|        |        |        |      |         |         |         |
|        |        |        | -->  |         |         |         |
|--------------------------|      |-----------------------------|
|        |        |        |      |         |         |         |
|        |        |        |      |         |         |         |
----------------------------      -------------------------------
```
Grid和Block都由一个三维坐标标识(dim3)，每个`(x,y,z)` 唯一确定一个网格或者一个块。

因此我们可以创建一个维度`(3,3,3)`的网格，每个网格又是一个维度为`(4,4,4)`的线程块。因此总线程数为 $ 3^3(网格数) * 4^3(线程数) $

1. 网格的维度由线程块的数量来表示
2. 线程块的维度由线程数来表示

在代码`MatrixSum`中：
```
dim3 block = (16);
dim3 grid = ((matrix_len + block.x - 1) / block.x);
```
这里计算所需要网格数的代码`((matrix_len + block.x - 1) / block.x)` 是为了让所有的数据能被网格所包括，因此加上`block.x-1`,这也是为了规避除法的向下取整，导致无法囊括到所有数据。

```
------------------------------------------------------------
| data1 | data2 |       |       |       |       |       |  |
|       |       |       |       |       |       |       |  |
------------------------------------------------------------
                                                            ^
                                                            |
-----------------------------------------------------------------
| block1| block2|       |       |       |       |       |       |
|       |       |       |       |       |       |       |       |
-----------------------------------------------------------------
    1       2       3       4       5       6       7       8
```

